HTTP1.0 —— 无状态无连接的应用层协议
无状态：服务器不跟踪不记录请求过的状态
无连接：浏览器每次请求都要建立TCP连接
HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）

无连接特性会导致以下的缺陷：

无法复用连接。每次发送请求都需要建立一次TCP连接，而TCP的连接释放过程是比较费事的，导致网络利用率非常低
队头堵塞。由于HTTP1.0规定下一个请求必须在前一个响应到达之前才能发送。假设一个请求响应一直不到达，那么下一个请求就不发送，就导致阻塞后面的请求。
为了解决这些问题，HTTP1.1出现了

HTTP1.1
1.长连接
HTTP1.1增加了一个Connection字段，通过设置keep-alive(默认已设置)可以保持连接不断开，避免每次客户端与服务器请求都要重复建立释放TCP连接，提高了网络的利用率。如果客户端想关闭HTTP连接，可以在请求头中携带Connection:false来告知服务器关闭请求

2. 支持请求管道化(pipelining)
基于长连接，使得请求管线化成为可能。管道化使得请求可以“并行传输”。

3.新增请求方式
PUT
DELETE
OPTIONS
TRACE
CONNECT
HTTP2.0
先来理解几个概念：

帧： HTTP2.0数据通信的最小单位消息：指HTTP2.0中逻辑上的HTTP消息。例如请求和响应等，消息由一个或多个帧组成
流：存在于连接中的一个虚拟通道，流可以承载双向消息，每个流都有一个唯一的整数ID
消息：与逻辑消息对应的完整的一系列数据帧
1.二进制分帧
HTTP2.0采用二进制格式传输数据，而非HTTP1.x的文本格式，二进制协议解析起来更加高效。HTTP2.0将请求和响应数据分割为更小的帧，并且采用二进制编码

2.多路复用
HTTP2.0实现了真正的并行传输，它能够在一个TCP上并行地发送任意数量HTTP请求，避免了队头堵塞。而这个强大的功能则是基于“二进制分帧”的特性。

3.头部压缩
HTTP1.x协议是无状态的，导致每次请求都必须附上所有信息。所以，请求的很多头字段都是重复的，比如Cookie，一样的内容每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制；

4.服务器推送
允许服务器可以在发送页面HTML时主动推送其他资源，而不用等到浏览器解析到相应位置，发起请求再响应。

例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。

服务器可以主动推送，客户端也有权利选择是否接收。

# HTTP与WebSocket区别，哪个更能减少性能
HTTP 和 WebSocket 都是应用层协议，但它们有一些重要的区别。

HTTP 是一种无状态协议，每次请求和响应都是独立的，而 WebSocket 是一种有状态协议，建立连接后，客户端和服务器之间可以保持长时间的双向通信。

HTTP 使用请求-响应模式，客户端向服务器发送请求，服务器返回响应。而 WebSocket 可以在客户端和服务器之间双向发送消息，不需要等待请求和响应。

HTTP 的通信方式是基于文本的，而 WebSocket 的通信方式是基于二进制的，可以传输更加复杂的数据类型。

由于 WebSocket 采用长连接的方式，可以避免重复建立和关闭连接的开销，因此在一些需要频繁通信的场景下，WebSocket 的性能会更好。而 HTTP 每次请求都需要建立连接，传输数据后再关闭连接，这种模式会产生较大的开销，因此在频繁通信的场景下，HTTP 的性能会比 WebSocket 更差。

需要注意的是，WebSocket 在建立连接时需要进行一次 HTTP 握手，因此在建立连接时会有额外的开销。但是，一旦连接建立成功，后续的通信会非常高效，因此在需要频繁通信的场景下，WebSocket 的性能会更好。

总的来说，WebSocket 的性能比 HTTP 更好，能够减少性能开销。但是，在一些特殊场景下，例如需要频繁建立和关闭连接的场景，HTTP 可能会更适合。
# 并发请求的限制是浏览器的，还是HTTP的？
并发请求的限制是由浏览器实现的，而不是由 HTTP 协议规定的。

浏览器对并发请求的限制是出于性能和资源管理的考虑。由于浏览器需要同时处理多个任务，例如渲染页面、执行 JavaScript 代码、下载资源等，如果同时发送大量的请求，会导致浏览器的性能和资源消耗增加，甚至会导致浏览器崩溃。

因此，浏览器会对并发请求进行限制。不同的浏览器对并发请求的限制可能不同，一般情况下，现代浏览器的并发请求限制在 6-8 个左右。如果需要发送更多的请求，可以通过一些技术手段，例如使用域名分片、使用 CDN、使用资源合并等方式来减少请求的数量，提高性能和用户体验。

需要注意的是，在服务器端也可以对并发请求进行限制，例如通过配置 Web 服务器或者应用服务器来限制并发连接数。但是，这种限制是针对服务器端的，并不影响浏览器端的行为。
# http二级域名 下cookie能否跨域？
HTTP 协议中规定，如果两个网站的域名不同，即使是同一个顶级域名，它们也被视为跨域。因此，在二级域名下，如果两个网站的二级域名不同，它们被视为跨域。

例如，www.example.com 和 blog.example.com 是不同的二级域名，它们被视为跨域。在这种情况下，如果网站 A（例如 www.example.com）向网站 B（例如 blog.example.com）发送 HTTP 请求，由于跨域的限制，网站 B 的响应将被浏览器拒绝。

对于 cookie，同样存在跨域的限制。如果两个网站的域名不同，它们之间的 cookie 也被视为跨域的。在二级域名下，如果两个网站的二级域名不同，它们之间的 cookie 也被视为跨域的。

例如，在 www.example.com 设置的 cookie，在 blog.example.com 是无法访问的。如果网站 A（例如 www.example.com）向网站 B（例如 blog.example.com）发送 HTTP 请求，由于跨域的限制，网站 B 无法访问网站 A 的 cookie。

需要注意的是，可以通过设置 cookie 的 domain 属性来解决跨域的问题。如果设置了 cookie 的 domain 属性为顶级域名（例如 .example.com），则该 cookie 可以在所有二级域名下访问。但是，这种做法存在安全风险，因此需要慎重使用。
# HTTP2.0的队头阻塞解决了吗？在哪一层解决的？

  HTTP/2 的队头阻塞问题得到了较好的解决。HTTP/2 采用了多路复用技术，可以在同一个连接上同时传输多个资源，多个请求/响应可以交错进行，不再像 HTTP/1.x 那样需要等待前面的请求/响应完成才能进行下一个。

  此外，HTTP/2 还引入了流的概念，每个流都可以独立地进行流量控制，这样就可以避免单个请求占用过多的带宽，导致其他请求被阻塞的问题。

  HTTP/2 的队头阻塞问题是在传输层（Transport Layer）解决的。HTTP/2 使用了新的二进制协议（Binary Framing Layer），将 HTTP 报文分割成一个个二进制帧（Frame）进行传输。在传输过程中，每个帧都有自己的流标识符和优先级信息，因此可以进行流量控制和优先级控制，从而解决了队头阻塞的问题。

  需要注意的是，虽然 HTTP/2 已经解决了队头阻塞的问题，但在实际应用中仍然需要注意优化请求的顺序和并发数，以充分利用 HTTP/2 的多路复用和流量控制机制，提高传输效率。

http里面嵌入https，https内嵌http？
# es6的新特性？weakMap在哪些场景下使用？(提到了set,map引申问我) 
weakMap 是 ES6 中新增的一种数据结构，它与 Map 类似，也是用于存储键值对的集合，但与 Map 不同的是，weakMap 中的键必须是对象，而且是弱引用，即如果键对象没有其他引用，会被垃圾回收机制回收。

weakMap 的主要应用场景是在需要存储对象与对象之间的关系时，可以使用 weakMap 来避免内存泄漏或者循环引用的问题。例如：

缓存对象的私有数据。可以将对象作为 weakMap 的键，将其私有数据作为值。这样即使对象被垃圾回收机制回收，与之对应的私有数据也会被自动清除，避免了内存泄漏的问题。

存储 DOM 节点的相关数据。在使用 DOM 编程时，常常需要为 DOM 节点存储一些相关的数据，例如事件处理函数等。可以使用 weakMap 来存储 DOM 节点与相关数据之间的关系，避免了循环引用的问题。

需要注意的是，由于 weakMap 中的键是弱引用，因此不能使用基本类型作为键，否则会抛出 TypeError 异常。另外，由于 weakMap 的键是弱引用，因此它的遍历顺序是不确定的，不能保证键值对的顺序。

在 Vue.js 源码中，使用了多个 weakMap 来存储一些私有数据，例如：

_init：在 Vue 实例初始化时，使用了一个名为 _init 的方法，其中使用了一个名为 _uid 的 weakMap，用于存储每个 Vue 实例的唯一 ID。

Dep：在 Vue.js 中，使用了一个名为 Dep 的类来实现数据的响应式。在 Dep 类中，使用了三个 weakMap：subs、newDeps 和 depIds。其中，subs 用于存储订阅该 Dep 对象的 Watcher 对象，newDeps 和 depIds 则用于存储该 Dep 对象所依赖的数据的相关信息。

VNode：在 Vue.js 中，使用了一个名为 VNode 的类来表示虚拟 DOM 节点。在 VNode 类中，使用了一个名为 context 的 weakMap，用于存储与该 VNode 对象相关的渲染上下文。

这些 weakMap 的作用都是用于存储一些私有数据，避免数据泄露和循环引用的问题。由于 weakMap 中的键是弱引用，因此在 Vue.js 中使用 weakMap 可以避免一些内存泄漏和循环引用的问题，提高了代码的健壮性和可维护性。
# Promise状态可逆？all与race方法？哪些宏任务哪些是微任务？
# 介绍webpack？ treeShaking的原理？常用loader，plugin？
对于循环引用的模块，tree shaking 的效果可能会受到影响，
因为循环引用会导致模块的依赖关系变得复杂，难以静态分析。

例如，如果模块 A 和模块 B 互相引用，那么在打包时，webpack 可能无法确定哪些导出变量是被使用的，
因为变量的使用可能发生在循环引用的过程中。

不过，webpack 提供了一些配置选项来解决循环引用的问题，例如通过设置 optimization.sideEffects 为 true，可以禁用 tree shaking 的功能，从而确保所有模块都会被打包到最终的文件中。

另外，如果循环引用的模块中有一些变量是确定被使用的，可以使用 /* harmony export */ 注释来标记这些变量，告诉 webpack 这些变量是需要被打包的，从而提高 tree shaking 的效果。